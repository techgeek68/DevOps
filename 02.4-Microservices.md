**Introduction to Microservices**

**What is a Microservice?**
    - A microservice is a software design pattern where applications are built as a collection of small, independent, loosely coupled services.
    - Each service:
      - Focuses on a single business capability (e.g., user authentication, payment processing).
      - Runs in its process and communicates via lightweight APIs (e.g., REST, gRPC).
      - Manages its data storage (decentralized databases).
    - Contrasts with monolithic architecture (single codebase where components are tightly integrated).

**Why Microservice Architecture?**
- **Scalability**:
  - Scale individual services independently based on demand (e.g., scaling a high traffic payment service).
- **Flexibility**:
  - Use different technologies (languages, frameworks) for various services.
- **Resilience**:
  - Fault isolation failures in one service don’t crash the entire system.
- **Faster Deployment**:
  - Teams can develop, test, and deploy services independently.
- **Organizational Alignment**:
  - Small teams own specific services, enabling agility and autonomy.
  
**Example**:
```
Scenario: Ride-Sharing Platform with Microservices

System Landscape
    - User Service: Manages rider and driver profiles in a SQL database.
    - Trip Service: matches riders and drivers, calculates Estimated Time of Arrival (ETA), and stores trip records.
    - Pricing Service: Computes dynamic fares based on demand, distance, and surge multipliers.
    - Notification Service: Publishes events (e.g., “ride confirmed”) to Apache Kafka, consumed by email/SMS workers.
    - API Gateway: Routes external Representational State Transfer REST/gRPC calls to each service.                                              Note:gRPC: Google Remote Procedure Call.


Key Design Decisions:

    1. Containerization & Orchestration: Each service runs in Docker on Kubernetes, enabling autonomous scaling (e.g., spin up more Trip pods during rush hour).

    2. Data Ownership: Every service owns its data store. (e.g., Redis for caching trip lookups, PostgreSQL for persistent records) to avoid cross service coupling.

    3. Inter service Communication :
        Synchronous: gRPC between User and Trip for authentication.
        Asynchronous: Kafka topics for events (e.g., pricing updates, notifications) to decouple producers/consumers

Resilience Patterns:
    - Circuit Breakers protect the Trip Service from cascading failures when Pricing is down.
    - Bulkheads isolate CPU intensive map matching jobs to dedicated nodes.
    - Retries with exponential backoff on external partner APIs (e.g., maps, payments).


Observability & Automation:
    - Distributed Tracing (Jaeger) reveals end-to-end latency (User → Trip →Pricing).
    - Prometheus + Grafana alert on Service Level Objective (SLO) breaches (e.g., >1.5 s 95th percentile trip create latency).
    - Chaos Engineering periodically kills a random Trip pod to verify graceful degradation and fallback to cached pricing.
```
