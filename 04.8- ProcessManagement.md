# 12. Process Management, System Monitoring, and Performance Tuning

---
**12.1 Process Management**

**A. Process Monitoring Tools**

**ps - Process Status**
- Snapshot of current processes

**Key Columns:**  
- Key Columns in ps aux:
- USER: Process owner
- PID: Process ID (unique identifier)
- %CPU: CPU usage percentage
- %MEM: Memory usage percentage
- VSZ: Virtual memory size
- RSS: Resident Set Size (physical memory)
- TTY: Terminal associated
- STAT: Process state
- START: Start time
- TIME: CPU time consumed
- COMMAND: Command line

**Process States (STAT column):**

 - R: Running or runnable
 - S: Interruptible sleep
 - D: Uninterruptible sleep
 - Z: Zombie process
 - T: Stopped
 - <: High priority
 - N: Low priority
  
```
# BSD-style (most commonly used)
ps aux
```

```
# Unix-style
ps -ef
```

```
# Show process tree
ps auxf
```

```
# Show processes for the specific user
Syntax: ps -u username

# Example:
ps -u cnode
```
<img width="678" height="128" alt="Screenshot 2025-10-29 at 12 13 37 PM" src="https://github.com/user-attachments/assets/fe5f4bde-135e-4f3f-9269-225bae7ed852" />

```
# Show processes by name
ps -C sshd
ps aux | grep nginx
```
<img width="1194" height="314" alt="Screenshot 2025-10-29 at 12 15 38 PM" src="https://github.com/user-attachments/assets/2133784a-e723-45d5-b12f-51841e7b7d56" />


```
# Show specific columns
ps -eo pid,ppid,user,%cpu,%mem,command
```
<img width="824" height="205" alt="Screenshot 2025-10-29 at 12 16 58 PM" src="https://github.com/user-attachments/assets/968a7005-a042-4bd7-a351-a11906634030" />


**top - Real-time Process Monitor**
- Interactive Process Viewer:
  ```bash
  top
  ```

**Key Interactive Commands in top:**
   Key	    Action
  - k	      Kill process (prompts for PID)
  - M	      Sort by memory usage
  - P	      Sort by CPU usage
  - T	      Sort by time
  - u	      Show processes for the specific user
  - 1	      Show individual CPU cores
  - h	      Help
  - q	      Quit

<img width="698" height="210" alt="Screenshot 2025-10-29 at 12 33 05 PM" src="https://github.com/user-attachments/assets/7e67f3d5-bc41-4dbb-a823-4d06c743d848" />


**Header Information:**
  - Load average: 1min, 5min, 15min
  - Tasks: Total, running, sleeping, stopped, zombie
  - %Cpu(s): User, system, idle, wait time
  - Memory: Total, free, used, buffers/cache
  - Swap: Total, free, used

**Key Columns:**
  - PID: Process ID (unique identifier)
  - USER: Process owner
  - PR: Priority of the process
  - NI: Nice value (priority adjustment, -20 to 19)
  - VIRT: Virtual memory size
  - RES: Resident memory (physical RAM used)
  - SHR: Shared memory
  - S: Process state (`R`=Running, `S`=Sleeping, `D`=Uninterruptible sleep, `T`=Stopped, `Z`=Zombie)
  - %CPU: CPU usage percentage
  - %MEM: Memory usage percentage
  - TIME+: Total CPU time consumed
  - COMMAND: Command or program name
  
<img width="893" height="803" alt="Screenshot 2025-10-29 at 12 24 29 PM" src="https://github.com/user-attachments/assets/f7a3049a-b181-49ec-9126-b6b3e0542f11" />



**htop - Enhanced Process Viewer**
- Improved interactive process viewer with color and tree view.

**Install:**  
```bash
# RHEL/CentOS/Fedora
sudo dnf install epel-release -y
sudo dnf install htop -y

# Ubuntu/Debian
sudo apt update
sudo apt install htop -y
```

**Run:**  
  ```bash
  htop
  ```
  
<img width="1286" height="802" alt="Screenshot 2025-10-29 at 12 49 10 PM" src="https://github.com/user-attachments/assets/498b744b-42f3-43d2-b4bf-ab6328ef1d7e" />

**Interactive Features:**
    Key	    Action
  - F1	     Help
  - F2	     Setup/configure
  - F3	     Search process
  - F4	     Filter processes
  - F5	     Tree view (process hierarchy)
  - F6	     Sort by column
  - F7	     Decrease nice value (higher priority)
  - F8	     Increase nice value (lower priority)
  - F9	     Kill process (send signal)
  - F10	     Quit

  
**Advantages over top:**
  - Color-coded display
  - Vertical and horizontal scrolling
  - Mouse support
  - Better tree visualization
  - Easy process killing and priority adjustment


> Use `htop` for intuitive resource usage and process tree visualization.




**Additional Process Monitoring Tools**

 - pstree - Process Tree Display
```
# Show process tree
pstree

# Show PIDs
pstree -p

# Show for specific user
pstree -u username
```

 - pgrep & pkill - Process Grep/Kill
```
# Find process IDs by name
pgrep nginx
pgrep -u root

# Kill processes by name
pkill nginx
pkill -u username process_name
```

 - pidof - Find PID of Running Program
```
pidof sshd
pidof nginx
```


**Process Information Files**
 - /proc Filesystem
```
# Process details
cat /proc/<PID>/status

# Process environment
cat /proc/<PID>/environ

# Open files
ls -la /proc/<PID>/fd/
```

<img width="571" height="89" alt="Screenshot 2025-10-29 at 12 57 49 PM" src="https://github.com/user-attachments/assets/95c8a872-9f86-4705-917c-85d8c334211f" />


---
**B. Process Signals**

- Signals are software interrupts for processes.
  
- **Common Signals:**
  | Signal Name | Number | Description                      |
  |-------------|--------|----------------------------------|
  | SIGHUP      | 1      | Hangup (reload config)           |
  | SIGINT      | 2      | Interrupt (Ctrl+C)               |
  | SIGKILL     | 9      | Force termination (cannot ignore)|
  | SIGTERM     | 15     | Graceful termination (default)   |

**Send signals:**
- **Force-kill process:**  
  ```bash
   kill -9 12345
  ```
- **Graceful termination:**  
  ```bash
   kill -15 12345
  ```
- **Kill all by name:**  
  ```bash
   killall -9 process_name
   pkill firefox
  ```

**Process Types:**
- **Zombie:** Finished, entry remains; usually harmless.
- **Orphan:** Parent died, adopted by init (PID 1).

 
> Prefer `SIGTERM` (15) over `SIGKILL` (9) for cleanup. Use tree view (`htop`, `pstree`) to avoid killing critical processes.


---
**C. Managing Background Jobs**

**Job Control Fundamentals**

- **Starting Background Jobs:**  

```bash
# Start command in background
sleep 60 &

# Output: [1] 1234  (Job ID: 1, Process ID: 1234)

# Start multiple background jobs
sleep 30 &
sleep 45 &
```
 
- **Job Management:**  
```bash
# List current jobs
jobs

# List with process IDs
jobs -l

# List with more details
jobs -p
```

<img width="701" height="291" alt="Screenshot 2025-11-02 at 8 54 38 AM" src="https://github.com/user-attachments/assets/9c1b9999-869d-4133-a400-9252fd51600e" />


**Job Control Operations**
```bash
# Bring background job to foreground
fg %1

# Suspend current foreground job
Ctrl + Z
# Job stops and returns to shell with message: [1]+  Stopped    sleep 60

# Resume suspended job in the background
bg %1

# Bring the most recent job to the foreground
fg
```

<img width="716" height="475" alt="Screenshot 2025-11-02 at 8 58 47 AM" src="https://github.com/user-attachments/assets/08d82bca-b1d4-4813-81e4-670c026be5ab" />


**Monitoring background jobs**
```
# Watch job status
watch -n 2 'jobs -l'

# Check process details
ps -p $(jobs -p)

# Monitor resource usage of background jobs
top -p $(jobs -p | tr '\n' ',' | sed 's/,$//')
```


**Referencing Jobs**
```bash
By job number:
 - %1                      #Job number 1
 - %2                      #Job number 2
By process name:
 - %sleep                  #Job running 'sleep'
 - %?vim                   #Job containing 'vim' in command
 - %%                      #Current job (the one most recently activated)
 - %+                      #Current job
 - %-                      #Previous job
```

Job States:
  - Running: Job is executing in the background
  - Stopped: Job is suspended (with Ctrl+Z)
  - Done: Job has completed execution

**Terminating Jobs**
```bash
# Kill by process name
kill %sleep

# Kill specific job
kill %1

# Send the specific signal
kill -TERM %1
kill -KILL %2
```

<img width="631" height="244" alt="Screenshot 2025-11-02 at 12 10 53 PM" src="https://github.com/user-attachments/assets/b4b83bcd-0203-437a-b97e-e08274960a21" />

<img width="630" height="202" alt="Screenshot 2025-11-02 at 12 11 02 PM" src="https://github.com/user-attachments/assets/3977c7f6-77a4-4fa9-a191-9bcd46599284" />


**Examples**

**Example 1: Development Workflow**
```bash
# Start web server in the background
python -m http.server 8000 &


# Start database in the background
mongod --dbpath /data/db &


# List a jobs
jobs
   [1]   Running    python -m http.server 8000 &
   [2]   Running    mongod --dbpath /data/db &

# Bring a web server to the foreground to check logs
fg %1
  - Press Ctrl+Z to suspend, then bg to return to background
```

<img width="709" height="258" alt="Screenshot 2025-11-02 at 12 20 01 PM" src="https://github.com/user-attachments/assets/7657573e-0bb1-456f-9332-b10e5f1b1f95" />


**Example 2: File Operations**
```
# Start large file copy in background
 cp -r large_directory /backup/ &


# Check job status periodically
jobs -l
  [1]  24567 Running    cp -r large_directory /backup/ &

# Continue working while copy runs in background

```

**Example 3: Interactive Session Management**
```
# Start text editor
vim document.txt

 - Press Ctrl+Z to suspend
 - [1]+  Stopped    vim document.txt

# Do other work, then return to editor
fg %1
```

**Example 4: Persistent Background Jobs**

 - Keeping Jobs Alive After Logout
```
# Use nohup to ignore hangup signals
 nohup ./long_running_script.sh &

# Use disown to remove job from shell's job table
 ./script.sh &
 jobs
 disown %1

# Using screen or tmux for session management
 tmux new -s mysession
 ./long_task.sh
 
# Detach: Ctrl+B, D
# Reattach: tmux attach -t mysession
```

> Manage long-running or interactive tasks using job control. Always check with `jobs`.


---
## 13.1 System Monitoring and Performance Tuning

**A. Monitoring System Performance**

**`vmstat` (Virtual Memory Statistics)**
 - Overview: virtual memory, processes, CPU, I/O.
 - Example: 
  ```bash
  # Basic usage (1-second intervals)
    vmstat 1

 # With custom interval and count
    vmstat 2 10      #Every 2 seconds, 10 times

- Key metrics to watch:
  - r: Running processes (if > CPU cores = bottleneck)
  - b: Processes in uninterruptible sleep
  - swpd: Used swap memory
  - si/so: Swap in/out (should be 0 in healthy system)
  - wa: I/O wait percentage (high = disk bottleneck)
  - us/sy/id: User, system, idle CPU time
  ```
  
<img width="850" height="411" alt="Screenshot 2025-11-02 at 12 46 51 PM" src="https://github.com/user-attachments/assets/eaf8627f-b65d-4fd3-8114-caa30ebd8290" />

**`iostat` (I/O Statistics)**
- Install:
```bash
# Installation
sudo dnf install sysstat -y    # RHEL/CentOS/Fedora
sudo apt install sysstat -y    # Ubuntu/Debian

# Basic usage (Displays CPU and device I/O usage)
iostat

# Extended I/O stats
iostat -x 1

# CPU and device statistics
iostat -c -d 1

- Key metrics:
# - %util: Device utilization percentage
# - await: Average I/O response time
# - r/s, w/s: Read/write operations per second
```

<img width="1282" height="686" alt="Screenshot 2025-11-02 at 12 56 27 PM" src="https://github.com/user-attachments/assets/92b3d43d-9e04-4d6d-8878-4419fb46a4b9" />


**`sar` (System Activity Reporter)**
- Install:  
```bash
  sudo dnf install sysstat -y

# Enable and start data collection
  sudo systemctl enable sysstat
  sudo systemctl start sysstat

# View CPU statistics
  sar -u

# View memory usage
  sar -r

# View I/O statistics
  sar -b

# Real-time monitoring
  sar -u 1 5  # CPU every 1 sec, 5 times
```

<img width="1055" height="497" alt="Screenshot 2025-11-02 at 1 02 09 PM" src="https://github.com/user-attachments/assets/cf0b2d29-700e-4bed-8377-f69f41c95f3a" />


**`free` (Memory Usage)**
- (Human-readable RAM and swap usage)
- Run:  
  ```bash
  free -h
  ```
 

**`htop` (Real-Time Monitoring)**
- Color-coded metrics: CPU, memory, swap.
- Sort: F6 (by CPU%, MEM%, user)
- Kill: F9
- Tree: F5


> Use `htop` for interactive and visual monitoring; combine with `vmstat`, `iostat`, `sar` for deep analysis.

---
**B. Setting Resource Limits**

ulimit:
- used to set or view resource limits for the current shell and any child processes it creates.

- **View current limits:**  
```bash
ulimit -a                    # Show all limits
ulimit -n                    # Show file descriptor limit
ulimit -u                    # Show max user processes
```

<img width="656" height="346" alt="Screenshot 2025-11-03 at 6 50 14 AM" src="https://github.com/user-attachments/assets/3a3e25df-c8fb-4ba4-8eee-b8452b6b3a2c" />

<img width="655" height="98" alt="Screenshot 2025-11-03 at 6 50 49 AM" src="https://github.com/user-attachments/assets/57a1ea40-cd44-4363-b1fb-566bce559275" />


- **Set temporary limits (current session):**  
```bash
ulimit -n 4096              # File descriptors
ulimit -u 2048              # Max user processes
ulimit -m 1048576           # Memory size (KB)
ulimit -v 2097152           # Virtual memory (KB)
```
<img width="655" height="435" alt="Screenshot 2025-11-03 at 6 53 17 AM" src="https://github.com/user-attachments/assets/02d02851-b61d-4fc4-b4de-34631c3c4869" />


**Persistent Limits**
- Edit configuration: Set in `/etc/security/limits.conf`
```
sudo vim /etc/security/limits.conf
```
Example entriees:
```
# user specific limits
username    soft    nofile    4096
username    hard    nofile    8192
username    soft    nproc     2048
username    hard    nproc     4096

# Group limits
@developers soft    nofile    8192
@developers hard    nofile    16384

# Wildcard for all users
*           soft    core      0          # Disable core dumps
*           hard    rss       1048576    # 1GB memory limit
```

<img width="649" height="260" alt="Screenshot 2025-11-03 at 7 11 07 AM" src="https://github.com/user-attachments/assets/f974d618-0652-4ea7-ab64-28c4f486372e" />


**item — what resource you limit**
 - core	- core dump size (KB)
 - data -	data segment size (heap)
 - fsize	- max file size (KB)
 - memlock	- locked-in-memory size (KB)
 - nofile	- max open file descriptors
 - rss	- max resident memory (KB)
 - stack	- stack size (KB)
 - cpu -	CPU time (minutes)
 - nproc	- number of processes
 - as	- address space limit (KB)
 - maxlogins	- max logins for a user
 - maxsyslogins	- total logins on system

**type — type of limit**
 - soft	- default value, user can raise it (up to hard)
 - hard	- upper ceiling, only root can raise it

**cgroups (Control Groups) - System-Level Limits**
- Control groups, are a Linux kernel feature that organizes processes into hierarchical groups to manage and limit system resources like CPU, memory, and network bandwidth.
- Only available in certain linux distros.

**Advanced cgroups (v2) and systemd resource slices**

**cgroup v2 (Modern systems):**
- cgroup v2 offers the unified hierarchy and better resource control.
- Example: Basic cgroup v2 operations
```
# 1. Mount the cgroup v2 filesystem (if not already mounted but most modern Linux distros mount this automatically at /sys/fs/cgroup)
 sudo mount -t cgroup2 none /sys/fs/cgroup


# 2. Create a cgroup
 sudo mkdir /sys/fs/cgroup/myapp

# 3. Set memory limit (e.g., 256 MB)
 echo $((256*1024*1024)) | sudo tee /sys/fs/cgroup/myapp/memory.max

# 4. Run a process in the cgroup
# Add the current shell process to the cgroup
 echo $$ | sudo tee /sys/fs/cgroup/myapp/cgroup.procs

# Or run a new process in the cgroup
 sudo sh -c "echo $$ > /sys/fs/cgroup/myapp/cgroup.procs; exec ./myprocess"

# 5. Monitor
 cat /sys/fs/cgroup/myapp/memory.current
 cat /sys/fs/cgroup/myapp/cpu.stat              
 cat /sys/fs/cgroup/myapp/cgroup.procs          #Check processes
```

**systemd Resource Control - systemd slices**:
- Used to group and limit system services.
  - Example: Configure service limits in `/etc/systemd/system/myservice.service`
 ```
[Unit]
Description=My Custom Application
After=network.target
Slice=myapp.slice

[Service]
ExecStart=/usr/bin/myapp
Restart=always
CPUQuota=50%
MemoryMax=256M
LimitNOFILE=4096
LimitNPROC=2048

[Install]
WantedBy=multi-user.target
```

**Create custom slice (/etc/systemd/system/myapp.slice):**
```
[Slice]
MemoryMax=1G
CPUQuota=80%
AllowedCPUs=0-3
```

Apply and verify:
```
systemctl daemon-reload
systemctl restart myservice
systemctl show myservice --property=MemoryCurrent,CPUUsageNSec
```

> Always set sensible resource limits for production processes to avoid system exhaustion. Use cgroup v2 and systemd slices for fine-grained control in modern systems.


---
## 13.2 Cloud/Container & Enterprise Monitoring Integrations

**A. Enterprise Monitoring**

- **Prometheus Stack**:  
  - Time-series database, collects metrics via exporters.
  - Integrate with **Grafana** for dashboards and alerting.
  - Visualize and set alerts in Grafana.
  - Example:
    ```yaml
    # prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'node_exporter'
    static_configs:
      - targets: ['localhost:9100']
  - job_name: 'myapp'
    static_configs:
      - targets: ['localhost:8080']
    ```

    Queries:
  ```promql
  # CPU usage
avg(rate(node_cpu_seconds_total[5m])) by (instance)

# Memory usage
node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes

# Disk space
node_filesystem_avail_bytes / node_filesystem_size_bytes * 100

# Custom application metric
rate(http_requests_total[5m])
 ```


- **New Relic / Datadog / Splunk**:  
  - Agents installed on hosts/containers.
  - Application and infrastructure metrics, traces, and logs.
  - Dashboards, alerting, anomaly detection.
  - Cloud platform integrations for deep visibility.
    
```bash
# Datadog agent installation
DD_AGENT_MAJOR_VERSION=7 DD_API_KEY=YOUR_API_KEY DD_SITE="datadoghq.com" bash -c "$(curl -L https://s3.amazonaws.com/dd-agent/scripts/install_script.sh)"

# Custom metric submission
echo -n "custom.metric:123|g|#environment:prod" | nc -u -w0 localhost 8125
```
 
> Centralize monitoring using enterprise platforms. Use labels/tags for environments and automate dashboard/report generation.

---
**B. Automated Alerting and Remediation**

- Monitor resource usage and process health.
- **Automated Scripts/Ansible**:
  - Trigger remediation scripts on alert (restart services, scale resources).
- **PagerDuty Integration**:
  - Connect monitoring tools to PagerDuty for incident escalation.
- **Examplew**:
  - Prometheus alert triggers webhook → Ansible playbook restarts service or scales deployment.
  - Datadog detects anomaly → sends alert to PagerDuty → Ops on-call notified.
        
```yaml
# alertmanager.yml
route:
  group_by: ['alertname']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 1h
  receiver: 'web.hook'

receivers:
- name: 'web.hook'
  webhook_configs:
  - url: 'http://127.0.0.1:5001/'

inhibit_rules:
- source_match:
    severity: 'critical'
  target_match:
    severity: 'warning'
  equal: ['alertname', 'dev', 'instance']
```

 - Ansible Remediation Playbook
```yaml
# remediation.yml
- name: Auto-remediate high memory usage
  hosts: all
  vars:
    memory_threshold: 90
  tasks:
    - name: Check memory usage
      shell: free | awk 'FNR == 2 {print $3/$2 * 100}'
      register: memory_usage
      
    - name: Restart service if memory high
      systemd:
        name: "{{ item }}"
        state: restarted
      loop: "{{ high_memory_services }}"
      when: memory_usage.stdout | float > memory_threshold
```

> Automate remediation for known failure scenarios. Always run playbooks/scripts with logging and dry-run mode for safety.

---
**C. Application-Level Monitoring (APM)**

- **APM tools** (New Relic, Datadog, Splunk, Elastic APM):
  - Instrument applications for response time, error rate, and transaction traces.
  - Identify code-level bottlenecks and slow queries.
  - Integrate with CI/CD pipelines for release monitoring.

- Datadog APM Setup
```python
from ddtrace import tracer

@app.route('/api/endpoint')
def api_endpoint():
    with tracer.trace('web.request', service='myapp') as span:
        # Business logic
        span.set_tag('http.status_code', 200)
```

APM Metrics:
 - Response Time: P95, P99 latencies
 - Error Rate: HTTP 5xx responses
 - Throughput: Requests per second
 - Business Metrics: Custom transaction tracking


> Instrument all critical applications and services. Set up alerting for latency/error thresholds.


**D. Kubernetes Resource Management**
- Container Resource Limits (Docker/Kubernetes)
 - Docker example:
```
docker run --memory=256m --cpus=0.5 --pids-limit=100 myapp
```
 - Kubernetes pod spec:
```
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: app
    image: myapp:latest
    resources:
      requests:
        memory: "128Mi"
        cpu: "250m"
      limits:
        memory: "256Mi"
        cpu: "500m"
        ephemeral-storage: "1Gi"
```
   
- Automatically scales pods based on CPU/memory/custom metrics.
  - Example
   - Horizontal Pod Autoscaler
    ```yaml
   apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: web-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: web
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 60
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 70
  - type: Pods
    pods:
      metric:
        name: packets-per-second
      target:
        type: AverageValue
        averageValue: 1k
    ```
    
  - Vertical Pod Autoscaler
```
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: myapp-vpa
spec:
  targetRef:
    apiVersion: "apps/v1"
    kind: Deployment
    name: myapp
  updatePolicy:
    updateMode: "Auto"
```

- **Node Autoscaling:**
  - Cloud providers support autoscaling clusters based on resource demand.
  - Integrate monitoring tools to trigger scale operations.


> Always define resource requests/limits for containers. Use HPA and node autoscaling for resilient, cost-effective infrastructure.

---

## 13.4 Security Hardening

```bash
# Set secure ulimit defaults in /etc/security/limits.conf
* hard core 0
* hard nproc 1000
* hard rss 1048576

# Configure systemd service security
[Service]
MemoryDenyWriteExecute=yes
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=strict
```

**Incident Response Checklist**
 - Detect: Monitoring alerts trigger
 - Diagnose: Use troubleshooting commands
 - Contain: Apply resource limits, kill processes
 - Remediate: Fix root cause, restart services
 - Learn: Document incident, update runbooks
 
---
## 13.5 References

- `man ps`, `man top`, `man htop`, `man kill`, `man pkill`, `man killall`
- `man vmstat`, `man iostat`, `man sar`, `man free`
- `man ulimit`, `man cgroups`
- [Linux Process Management](https://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html)
- [htop](https://htop.dev/)
- [Kubernetes Resource Management](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/)
- [Kubernetes HPA](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)
- [Prometheus](https://prometheus.io/docs/introduction/overview/)
- [Grafana](https://grafana.com/docs/)
- [New Relic](https://docs.newrelic.com/docs/apm/)
- [Datadog Infrastructure Monitoring](https://docs.datadoghq.com/infrastructure/)
- [Splunk Observability](https://docs.splunk.com/Documentation/Observability)
- [Elastic APM](https://www.elastic.co/guide/en/apm/get-started/current/overview.html)
- [AWS CloudWatch](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html)
- [Azure Monitor](https://learn.microsoft.com/en-us/azure/azure-monitor/)
- [GCP Monitoring](https://cloud.google.com/monitoring/docs)
---
