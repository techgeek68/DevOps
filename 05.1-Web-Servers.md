# Web Servers:

---

This comprehensive guide explains how to install and configure both Apache and Nginx web servers to host static, PHP, and Python based websites. It also details how to secure these servers using HTTPS, implement advanced security practices, and apply enterprise level optimizations to ensure better performance, scalability, and reliability.

---

**Web Servers:**

 - A software application or a combination of hardware and software that stores, processes, and delivers web pages to users via HTTP/HTTPS.
   - Hardware:
     - Physical machine storing server software and website files, connected to the internet.
   - Software:
     - Applications like Apache, Nginx, and IIS that process requests and manage content delivery.
- Functions/Features:
  - Storing Content, Request handling, load balancing, SSL termination, Caching, Handling Protocols
- Types:
  - Static:
    - Serve pre existing files (HTML, CSS, JS, images)
  - Dynamic:
    - Process requests via applications (Python, PHP, Node.js)
    

**Popular Web Servers**

**Nginx**
- Architecture:
  - Event driven:
    - Nginx responds to network events (like data arrival or connection requests) via an event loop that monitors multiple connections simultaneously, rather than polling or waiting in a blocking manner.
  - Asynchronous:
    - I/O operations (disk reads, network requests) are initiated, and the worker process continues executing other tasks, getting notified when the operation completes instead of waiting idly.
  - Non blocking I/O:
    - Read/write operations return immediately, even if no data is available, allowing the worker to handle other connections instead of being stuck waiting for a single slow operation.
  - Master worker process model (single threaded event loop per worker):
    - A master process manages configuration and spawns worker processes (typically one per CPU core), where every single threaded worker runs its own event loop to handle thousands of connections efficiently without context switching overhead.
      
- Use:
  - Reverse proxy, load balancer, static content server
  - High concurrency, keep alive intensive workloads
    
- Configuration:
  - Debian/Ubuntu: `/etc/nginx/nginx.conf`, server blocks in `/etc/nginx/sites-available/` (linked to `/etc/nginx/sites-enabled/`)
  - RHEL/CentOS: `/etc/nginx/nginx.conf`, server blocks in `/etc/nginx/conf.d/`
    
- Pros:
  - High performance, low memory footprint
  - Handles thousands of concurrent connections efficiently
  - Market Share (2026) ~(33–43)% (Leading web server globally) 

**Apache HTTP Server**
- Architecture:
  - Process/Thread based with MPM
    - Apache uses interchangeable Multi Processing Modules (MPMs) that determine how the server handles concurrent connections. Only one MPM can be active at a time, chosen based on application needs and module thread safety requirements.
    - mpm_prefork (Process based, Non threaded):
      - Each client connection is handled by a dedicated child process without threads, providing maximum stability and compatibility with non thread safe modules (like mod_php), but consuming more memory and scaling poorly under high loads
    - mpm_worker (Hybrid Multi process, Multi threaded):
      - Apache spawns multiple child processes, each containing many threads, where each thread handles its own connection, offering better scalability and memory efficiency than prefork but requiring all modules to be thread safe.
    - mpm_event (Enhanced Worker, Optimized for Keep alive):
      - Built on mpm_worker with event driven enhancements, dedicated listener threads asynchronously manage keep alive and idle connections, freeing worker threads for active requests, making it the default on modern systems for optimal high concurrency performance
    
- Configuration :
  - Debian/Ubuntu: `/etc/apache2/apache2.conf`, `.htaccess`, MPM configs in `/etc/apache2/mods-available/mpm_*.conf`
  - RHEL/CentOS: `/etc/httpd/conf/httpd.conf`, `.htaccess`, MPM configs in `/etc/httpd/conf.modules.d/00-mpm.conf`
    
- Pros :
 - Modular (extensive module ecosystem), extensive feature set
 - Strong compatibility, long standing community support
 - Market Share (2026) ~10–36%

**- Other Notable Web Servers:**
  - Caddy
    - Features:
      - Automatic HTTPS (Let's Encrypt), simple configuration, written in Go
    - Uses:
      - Modern web apps, microservices, developers seeking simplicity
    - Market Share (2026) ~0.3–0.6%
     
  - LiteSpeed
    - Features:
      - Drop in Apache replacement, faster for static and dynamic PHP content, built in caching
    - Uses:
      - WordPress hosting, performance critical PHP applications
    - Market Share (2026) ~5–16%
     
  - Apache Tomcat
    - Features:
      - Java Servlet and JSP container
    - Uses:
      - Java EE web applications, enterprise environments
    - Market Share (2026) ~1%
     
  - Microsoft IIS (Internet Information Services)
    - Features:
      - Windows Server integration, .NET and ASP.NET support
    - Uses:
      - Windows enterprise environments, intranet applications
    - Market Share (2026) ~3–8%
     
**Other Examples:**
   - Jigsaw (W3C's experimental web server)
   - Oracle iPlanet Web Server
   - Lighttpd (lightweight, event driven)
   - Kestrel (cross platform web server for ASP.NET Core)
    
---

**SSH Login for Remote Server Access**
- Linux/Unix:
  - Syntax:
  ```bash
    ssh devops@<Server_IP> or <Server_hostname>
  ```

- Windows: 
  - For Windows 8 and earlier:
   - Download & install [MobaXterm](https://mobaxterm.mobatek.net/)  
     - Start local terminal
    
  - SSH works natively on Windows 10 (build 1809 and later) and Windows 11
    - Open a terminal (Command Prompt, PowerShell, or Windows Terminal).
    - Check if SSH is installed by typing ssh; a usage message means it’s ready.
    
> If not installed, go to Settings > Apps > Optional features > Add a feature and install OpenSSH Client.

 - Example:
   - Default port
  ```bash
  ssh devops@192.168.100.172
 ```
   - Custom port
 ```bash
  ssh -p 2222 devops@server-ip 
  ```

**SSH Configuration File (~/.ssh/config)**

- Example:
  
```bash
Host webserver
    HostName 192.168.100.172
    User devops
    Port 22
    IdentityFile ~/.ssh/webserver_key

Host appserver
    HostName 192.168.100.173  
    User devops
    ProxyJump webserver
```


---

**SELinux and Security**

- Check SELinux status:
  ```bash
  getenforce
  ```
  
- View logs:
  ```bash
  sudo cat /var/log/audit/audit.log | grep nginx
  ```
  
- List and set booleans:
  ```bash
  getsebool -a
  getsebool -a | grep network
  setsebool -P httpd_can_network_connect=1
  getsebool -a | grep httpd_can_network_connect
  ```

---

**Apache HTTP Server (Apache)**

Introduction:
 * Free, open source, cross platform(Runs on Linux, Windows, macOS, Unix, and other operating systems) web server
 * Developed and maintained by the Apache Software Foundation (ASF)
 * Core component of the LAMP stack (Linux, Apache, MySQL, PHP/Python/Perl)

Features
 * Modular Architecture
   * Highly extensible via loadable modules (enable/disable features as needed), modules include:
     * mod_ssl (SSL/TLS support for HTTPS)
     * mod_rewrite (URL rewriting and redirects)
     * mod_security (web application firewall)
     * mod_proxy (reverse proxy and load balancing)
     * mod_auth_* (authentication modules)
     * Support for dynamic languages via mod_php, mod_python, mod_perl, etc.
      
 * Flexible Configuration
   * `.htaccess support`: Directory level configuration without modifying the main server config
     * Enables per directory security, redirects, authentication, and custom error pages
     * Useful for shared hosting environments where users lack root access
       
> Note: For better security, disable directory indexing with `Options -Indexes` to prevent file browsing
     
 * Virtual Hosting
   * Supports name based and IP based virtual hosts
   * Enables hosting multiple websites on a single server

 * Strong Security
   * Regular security updates and patches
   * Built in modules for SSL/TLS, authentication, and access control
   * Custom error documents to hide server details
   * IP based restrictions, password protection (`.htpasswd`), and user agent filtering
   * Hide server signature: `ServerSignature Off` and `ServerTokens Prod`
   * Use `mod_security` for web application firewall (WAF) protection
   * Keep Apache and modules updated

 * Basic Operation
   * Listens on HTTP/HTTPS ports (default: 80 for HTTP, 443 for HTTPS)
   * Receives client requests for web pages or resources
   * Processes requests based on configuration (serves static files, executes scripts, proxies to backend)
   * Returns responses to clients (HTML, CSS, images, JSON, etc.)

 * Uses:
   * Static Website Hosting
     * Serves HTML, CSS, JavaScript, images, and other static files efficiently
       
   * Dynamic Website Hosting
     * Executes server side scripts using:
       * PHP (via mod_php or PHP-FPM)
       * Python (via mod_wsgi or CGI)
       * Perl (via mod_perl or CGI)
         
   * Reverse Proxy & Load Balancing
     * Acts as a reverse proxy to forward requests to backend application servers (Node.js, Tomcat, etc.)
     * Distributes traffic across multiple servers for load balancing
     * Modules: mod_proxy, mod_proxy_http, mod_proxy_balancer

  * API Gateway
    * Serves RESTful APIs and microservices
    * Can handle authentication, rate limiting, and SSL termination
      
  * Development & Testing
    * Bundled in local development stacks (XAMPP, MAMP, WAMP) for rapid prototyping

 
**A. Install & Start Apache (CentOS/RHEL/Fedora)**

- Check if the Apache HTTP Server package is installed
```bash
rpm -q httpd              
```

- Update all installed packages to the latest version automatically (Optional)
```bash
sudo yum update -y
```

- Install Apache HTTP Server without prompting for confirmation
```bash
sudo yum install httpd -y
```

 - Start the Apache HTTP Server service immediately & enable Apache to start automatically at boot
```bash
sudo systemctl start httpd   
sudo systemctl enable httpd    
```

 - Check the status of the Apache service
```bash
sudo systemctl status httpd
```

 - Display Apache version
```bash
httpd -v                    
```
<img width="663" height="87" alt="Screenshot 2025-11-05 at 12 06 30 PM" src="https://github.com/user-attachments/assets/718733de-b209-4ab6-98ae-4aa51583eba8" />


**B. Open Firewall Ports**

 - Open HTTP port (80) & HTTPS port (443) permanently
```bash
sudo firewall-cmd --permanent --add-service={http,https}
```
 - Apply the new firewall rules
```bash
sudo firewall-cmd --reload                                
```
 - Verify active services and open ports
```bash
sudo firewall-cmd --list-all                              
```

<img width="665" height="471" alt="Screenshot 2025-11-05 at 12 13 53 PM" src="https://github.com/user-attachments/assets/40e7d132-f844-4ece-b38d-f8190a72a673" />

<img width="659" height="363" alt="Screenshot 2025-11-05 at 12 19 20 PM" src="https://github.com/user-attachments/assets/7a8673aa-d79c-4a01-aa69-5b4c08a16eba" />


**C. Verify Installation**
  - Visit:
    - http://server-ip
          or
    - http://localhost
          or
    - http://127.0.0.1

<img width="805" height="575" alt="Screenshot 2025-11-05 at 12 22 18 PM" src="https://github.com/user-attachments/assets/1ee0d323-42d5-4e2e-bbea-c6a4d62cff7e" />

      
  - Check hosts: cat /etc/hosts
  
  <img width="716" height="165" alt="Screenshot 2025-11-05 at 12 20 24 PM" src="https://github.com/user-attachments/assets/71fb04f2-84e4-4261-9670-6d6a5b9a8655" />


---

**Hosting a Static Website**

**A. Directory Setup**
 - Create a web directory
```bash
sudo mkdir -p /var/www/html
sudo mkdir -p /var/www/html/{page1,page2}
```
 - Set permissions
```bash
sudo chown -R apache:apache /var/www/html
sudo chmod -R 755 /var/www/html
```
 - Verify ownership
```bash
ls -lh /var/www/
```

**B. Create Pages**

```bash
sudo vim /var/www/html/index.html
```

```bash
<!DOCTYPE html>
<html>
<head>
    <title>Static Website</title>
</head>
<body>
    <h1>This is a static website!!!</h1>
    <p><a href="/page1">Page 1</a> | <a href="/page2">Page 2</a></p>
</body>
</html>
```

**Subdirectory pages**

`sudo vim /var/www/html/page1/index.html`
```bash
<h1> Hello from the first page! </h1>
```

`sudo vim /var/www/html/page2/index.html`
```
<h1> Hello from the second page! </h1>
```

Check Syntax Error:
```
httpd -t
```

```bash
sudo systemctl restart httpd
```

**C.Test**
Visit: `http://localhost/`, `http://localhost/page1`, `http://localhost/page2`

<img width="805" height="389" alt="Screenshot 2025-11-06 at 6 55 19 AM" src="https://github.com/user-attachments/assets/6ca15a94-c969-4b3f-baa6-e20f0d0719f4" />

<img width="804" height="321" alt="Screenshot 2025-11-06 at 6 56 23 AM" src="https://github.com/user-attachments/assets/b6d14714-b4c2-4208-b8e5-10d6f2979220" />


<img width="805" height="334" alt="Screenshot 2025-11-06 at 6 56 44 AM" src="https://github.com/user-attachments/assets/068febe6-bdae-4a8a-80f5-94307eed17b7" />

---

**4. Apache Main Configuration**

- Main config file: `/etc/httpd/conf/httpd.conf`
- Key directives to check
  
```bash
DocumentRoot "/var/www/html"   # Directory where website files are served from
ServerRoot "/etc/httpd"        # Location of the Apache server’s configuration files
Listen 80                      # Apache listens for incoming connections on port 80
```
  
<img width="662" height="469" alt="Screenshot 2025-11-06 at 6 58 43 AM" src="https://github.com/user-attachments/assets/8bb4e908-cf91-4f46-b60c-2c6da80ff26f" />

---

**5. Virtual Host**:
 - A Virtual Host is a method for hosting multiple websites (with separate domain names) on a single Apache server. Instead of requiring multiple physical machines, Apache uses the requested domain name or IP address to determine which website's content to serve.
  - IP-based Virtual Hosts
    - Different websites use different IP addresses on the same server.
 
  - Name-based Virtual Hosts
    - Different websites share the same IP address, and Apache distinguishes them by the domain name in the Host: HTTP header. This is the most common method.

  
**Virtual Host Configuration**:
  - Syntax and Directives
```bash
<VirtualHost [IP_Address]:[Port]>                     # Defines a virtual host for a specific IP and port
    ServerName www.example.com                         # Primary domain handled by this virtual host
    ServerAlias example.com *.example.org              # Alternate domains served by the same configuration
    ServerAdmin webmaster@example.com                  # Contact email for the server administrator
    DocumentRoot /var/www/example.com/html             # Directory containing the website’s files

    <Directory /var/www/example.com/html>              # Applies settings to the DocumentRoot directory
        AllowOverride All                              # Enables use of .htaccess files
        Require all granted                             # Allows all clients to access the site
    </Directory>

    ErrorLog ${APACHE_LOG_DIR}/example.com_error.log             # File to store error messages for this site
    CustomLog ${APACHE_LOG_DIR}/example.com_access.log combined  # File and format for access logs
</VirtualHost>                                                   # End of virtual host definition
``` 

**Example 1:**
   - Let's create a virtual host for myapp.com.np
   
   - Create the Directory Structure
```bash
sudo mkdir -p /var/www/myapp.com.np
```

   - Assign Ownership and Permissions
```bash
sudo chown -R $USER:$USER /var/www/myapp.com.np
sudo chmod -R 755 /var/www/myapp.com.np
```

 - Create a Sample index.html File
```bash
sudo vim /var/www/myapp.com.np/index.html
```
 - Add content
 ```html
<html>
  <head>
    <title>Welcome to MyApp!</title>
  </head>
  <body>
    <h1>Success! The myapp.com.np virtual host is working!</h1>
  </body>
</html>
```

   - Create the Virtual Host File 
 ```bash
 sudo nano /etc/apache2/sites-available/myapp.com.np.conf       #Debian/Ubuntu
 
 sudo vim /etc/httpd/conf.d/myapp.com.np.conf                   #RedHat/CentOS/Fedora
 ```
 
   - Edit DocumentRoot file: `sudo vim /etc/httpd/conf/httpd.conf`
<img width="787" height="474" alt="Screenshot 2025-11-06 at 12 21 16 PM" src="https://github.com/user-attachments/assets/7a3fb938-e204-4354-9237-79aa4232daf9" />

   
   - Add the following configuration:
 ```apache
<VirtualHost *:80>                                             # Virtual host listening on port 80 (HTTP)
    ServerName myapp.com.np                                    # Primary domain name for this website
    ServerAlias www.myapp.com.np                               # Additional domain name pointing to the same site
    DocumentRoot /var/www/myapp.com.np                         # Directory where the website files are stored
    ErrorLog /var/log/httpd/myapp.com.np_error.log             # File where Apache logs errors for this site
    CustomLog /var/log/httpd/myapp.com.np_access.log combined  # File and format for access logs

    # Directory settings
    <Directory "/var/www/html/myapp.com.np">               # Configuration for this site’s root directory
        Options Indexes FollowSymLinks                     # Enables directory listing and symbolic links
        AllowOverride All                                  # Allows use of .htaccess files for overrides
        Require all granted                                # Grants access to all clients
    </Directory>
</VirtualHost>                                             # End of virtual host configuration
 ```
<img width="528" height="471" alt="Screenshot 2025-11-06 at 12 17 40 PM" src="https://github.com/user-attachments/assets/4321cfc7-8d18-466f-96d6-2291d185939e" />

 ```bash
  httpd -t                         #Check Syntax
  sudo httpd -S                    #Show vhosts
 ```
<img width="1022" height="109" alt="Screenshot 2025-11-06 at 12 18 05 PM" src="https://github.com/user-attachments/assets/31e90c18-fe95-48e5-86d6-643c61ae5fca" />

 - Reload HTTPD Service
```
systemctl restart httpd
```
 - Test the page

![Screenshot 2025-11-06 at 12 24 54 PM](https://github.com/user-attachments/assets/4a2da4b6-4b87-430f-b026-b762b1f8a03a)


**Example 2: Multiple Websites with Virtual Hosts**

- Directory Structure
```bash
# Create directories for multiple sites
sudo mkdir -p /var/www/example1.com
sudo mkdir -p /var/www/example2.com

# Set permissions
sudo chown -R apache:apache /var/www/example1.com
sudo chown -R apache:apache /var/www/example2.com
sudo chmod -R 755 /var/www
```

- Create sample web pages
   `sudo vim /var/www/example1.com/index.html`
```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>example1.com — It works!</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 2rem; }
    .card {
      max-width: 720px; margin: 0 auto; padding: 2rem;
      border-radius: 12px; border: 1px solid #d0d7de;
    }
    h1 { margin: 0 0 .5rem; }
    code { background: rgba(127,127,127,.15); padding: .2rem .4rem; border-radius: 6px; }
  </style>
</head>
<body>
  <div class="card">
    <h1>It works! example1.com</h1>
    <p>You are seeing the site served from <code>/var/www/example1.com</code>.</p>
    <p>ServerName: <strong>example1.com</strong></p>
    <p>If this is not the site you expected, check your VirtualHost <code>DocumentRoot</code> and <code>ServerName</code> settings.</p>
  </div>
</body>
</html>
```

   `sudo vim /var/www/example2.com/index.html`
```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>example2.com — It works!</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 2rem; }
    .card {
      max-width: 720px; margin: 0 auto; padding: 2rem;
      border-radius: 12px; border: 1px solid #d0d7de;
    }
    h1 { margin: 0 0 .5rem; }
    code { background: rgba(127,127,127,.15); padding: .2rem .4rem; border-radius: 6px; }
  </style>
</head>
<body>
  <div class="card">
    <h1>It works! example2.com</h1>
    <p>You are seeing the site served from <code>/var/www/example2.com</code>.</p>
    <p>ServerName: <strong>example2.com</strong></p>
    <p>If this is not the site you expected, check your VirtualHost <code>DocumentRoot</code> and <code>ServerName</code> settings.</p>
  </div>
</body>
</html>
```

- Virtual Host Configurations
  `sudo vim /etc/httpd/conf.d/example1.com.conf`
```apache
<VirtualHost *:80>
    ServerAdmin admin@example1.com
    ServerName example1.com
    ServerAlias www.example1.com
    DocumentRoot /var/www/example1.com

    ErrorLog /var/log/httpd/example1_error.log
    CustomLog /var/log/httpd/example1_access.log combined

    <Directory "/var/www/example1.com">
        Options -Indexes +FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>
</VirtualHost>
```

 `sudo vim /etc/httpd/conf.d/example2.com.conf`
```apache
<VirtualHost *:80>
    ServerAdmin admin@example2.com
    ServerName example2.com
    ServerAlias www.example2.com
    DocumentRoot /var/www/example2.com

    ErrorLog /var/log/httpd/example2_error.log
    CustomLog /var/log/httpd/example2_access.log combined

    <Directory "/var/www/example2.com">
        Options -Indexes +FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>
</VirtualHost>
```
  
```bash
sudo apachectl configtest
sudo systemctl restart httpd
```

 - Local Testing Setup
   - Edit `sudo vim /etc/hosts` on your local machine:
```text
192.168.100.172 example1.com
192.168.100.172 example2.com
192.168.100.172 www.example1.com
192.168.100.172 www.example2.com
```

 - On your browser
   - http://www.example1.com/
<img width="794" height="371" alt="Screenshot 2025-11-06 at 12 52 46 PM" src="https://github.com/user-attachments/assets/19eac9b3-6617-436b-a96e-726ee89ade0e" />


   - http://www.example2.com/
<img width="803" height="379" alt="Screenshot 2025-11-06 at 12 53 33 PM" src="https://github.com/user-attachments/assets/edcdfe83-4260-45f4-9bb4-cb56a85ec6ea" />


---


**6. Hosting PHP Websites**

Apache supports two primary methods for processing PHP:

- mod_php (Traditional)
  - PHP runs as an Apache module
  - Simpler setup, but less flexible
  - All Apache child processes load PHP, consuming more memory

- PHP-FPM (FastCGI Process Manager) (Recommended)
  - PHP runs as a separate process
  - Better performance, especially for high-traffic sites
  - More secure and resource-efficient
  - Supports different PHP versions for different sites


**A. Install PHP and Dependencies**

 - For RHEL/CentOS/Fedora:
```bash
sudo dnf install php php-fpm php-mysqlnd php-json php-xml php-mbstring -y  # Install PHP and common PHP modules
sudo dnf install php php-cli php-common -y                                 # Install Apache PHP module (mod_php) components

sudo systemctl start php-fpm                                               # Start PHP-FPM service
sudo systemctl enable php-fpm                                              # Enable PHP-FPM to start at boot
sudo systemctl status php-fpm                                              # Check PHP-FPM service status

php -v                                                                     # Display PHP version
```

**B. Configure Firewall**
```bash
# Open HTTP and HTTPS ports
sudo firewall-cmd --permanent --add-service=http
sudo firewall-cmd --reload

# Alternative: Open specific ports
sudo firewall-cmd --permanent --add-port=80/tcp
sudo firewall-cmd --reload
```

**C. Virtual Host Configuration**

 - `sudo vim /etc/httpd/conf.d/phpwebsite.conf`

- Method 1: Using PHP-FPM (Recommended)
```apache
<VirtualHost *:80>
    ServerAdmin admin@phpwebsite.local
    ServerName phpwebsite.local
    DocumentRoot /var/www/phpwebsite
    
    # PHP handling via PHP-FPM with ProxyFCGI
    <FilesMatch \.php$>
        SetHandler "proxy:unix:/run/php-fpm/www.sock|fcgi://localhost"
    </FilesMatch>
    
    # Alternative syntax for some distributions
    # <FilesMatch \.php$>
    #    SetHandler "proxy:fcgi://127.0.0.1:9000"
    # </FilesMatch>
    
    <Directory "/var/www/phpwebsite">
        Options -Indexes +FollowSymLinks +MultiViews
        AllowOverride All
        Require all granted
        
        # Security headers
        Header always set X-Content-Type-Options nosniff
        Header always set X-Frame-Options DENY
    </Directory>
    
    # Log configuration
    ErrorLog /var/log/httpd/phpwebsite_error.log
    CustomLog /var/log/httpd/phpwebsite_access.log combined
    LogLevel warn
</VirtualHost>
```

- Method 2: Using mod_php (Traditional)
```apache
<VirtualHost *:80>
    ServerAdmin admin@phpwebsite.local
    ServerName phpwebsite.local
    DocumentRoot /var/www/phpwebsite
    
    # With mod_php, PHP processing is automatic
    # Ensure mod_php is loaded: LoadModule php_module modules/libphp.so
    
    <Directory "/var/www/phpwebsite">
        Options -Indexes +FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>
    
    ErrorLog /var/log/httpd/phpwebsite_error.log
    CustomLog /var/log/httpd/phpwebsite_access.log combined
</VirtualHost>
```

**D. Directory Structure and Permissions**
```bash
sudo mkdir -p /var/www/phpwebsite
```

```bash
sudo vim /var/www/phpwebsite/index.php
```
```php
<?php
// Basic PHP info page
phpinfo();

// Display server information
echo "<h3>Server Environment:</h3>";
echo "Server Name: " . $_SERVER['SERVER_NAME'] . "<br>";
echo "Document Root: " . $_SERVER['DOCUMENT_ROOT'] . "<br>";
?>
EOF
```

```bash
sudo chown -R apache:apache /var/www/phpwebsite              # Set Apache as the owner and group for the website directory
sudo chmod -R 755 /var/www/phpwebsite                        # Give owner full access, others read and execute permissions for directories
sudo find /var/www/phpwebsite -type f -exec chmod 644 {} \;  # Set file permissions to read/write for owner and read-only for others
```
  
**E. Final Configuration and Testing**
```bash
sudo httpd -t                                 # Test Apache configuration syntax for errors


sudo systemctl restart php-fpm                # Restart PHP-FPM service to apply changes
sudo systemctl restart httpd                  # Restart Apache service


sudo systemctl enable php-fpm                 # Enable PHP-FPM to start automatically at boot
sudo systemctl enable httpd                   # Enable Apache to start automatically at boot

sudo systemctl status php-fpm                 # Check current status of PHP-FPM service
sudo systemctl status httpd                   # Check current status of Apache service
```

Test: `http://127.0.0.1/`
<img width="994" height="693" alt="Screenshot 2025-11-07 at 7 03 20 AM" src="https://github.com/user-attachments/assets/a0311338-1f86-4c01-813c-0447160c115d" />


---


**7. Hosting Python Websites (mod_wsgi)**

- Installation and Setup
  - Install Apache, Python, mod_wsgi
  
```bash
# For RHEL/CentOS/Fedora:
sudo dnf install httpd python3 python3-mod_wsgi -y

# Start and enable Apache
sudo systemctl start httpd
sudo systemctl enable httpd

# Verify mod_wsgi installation
sudo httpd -M | grep wsgi
```

 - Configure Firewall
```bash
# Open HTTP and HTTPS ports
sudo firewall-cmd --permanent --add-service=http
sudo firewall-cmd --permanent --add-service=https
sudo firewall-cmd --reload

# Alternative: Open specific ports
sudo firewall-cmd --permanent --add-port=80/tcp
sudo firewall-cmd --permanent --add-port=443/tcp
sudo firewall-cmd --reload
```

 - Directory Structure and Application Setup
   - Create Project Directory and WSGI Application
   
```bash
# Create project directory
sudo mkdir -p /var/www/python
```
```bash
# Create WSGI application file
sudo vim /var/www/python/myweb.wsgi
```

```python
#!/usr/bin/python3
import sys

# Add your application's directory to Python path
sys.path.insert(0, '/var/www/python')

def application(environ, start_response):
    # Set response headers
    status = '200 OK'
    response_headers = [('Content-type', 'text/html; charset=utf-8')]
    start_response(status, response_headers)
    
    # HTML response
    html = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Python WSGI App</title>
    </head>
    <body>
        <h1>Hello from Python WSGI!</h1>
        <p>This is a Python web application running on Apache with mod_wsgi.</p>
        <h3>Server Information:</h3>
        <ul>
            <li>Python Version: {version}</li>
            <li>Server Software: {software}</li>
            <li>Request Method: {method}</li>
        </ul>
    </body>
    </html>
    """.format(
        version=sys.version.split()[0],
        software=environ.get('SERVER_SOFTWARE', 'Unknown'),
        method=environ.get('REQUEST_METHOD', 'GET')
    )
    
    return [html.encode('utf-8')]
```

 - Set Proper Permissions
```bash
# Set ownership to Apache user
sudo chown -R apache:apache /var/www/python

# Set appropriate permissions
sudo chmod -R 755 /var/www/python
sudo chmod 644 /var/www/python/*.wsgi
sudo chmod 644 /var/www/python/*.py

# For RHEL/CentOS/Fedora, the Apache user is typically 'apache'
# For Debian/Ubuntu, the Apache user is typically 'www-data'
```

 - Virtual Host Configuration
   `sudo vim /etc/httpd/conf.d/python.conf`
   
```apache
<VirtualHost *:80>
    ServerAdmin admin@python.local
    ServerName python.local
    ServerAlias localhost 127.0.0.1

    DocumentRoot /var/www/python

    WSGIDaemonProcess python-app user=apache group=apache threads=5
    WSGIScriptAlias / /var/www/python/myweb.wsgi

    <Directory /var/www/python>
        WSGIProcessGroup python-app
        WSGIApplicationGroup %{GLOBAL}
        Require all granted
        Options -Indexes +FollowSymLinks
        AllowOverride All
    </Directory>

    Alias /static /var/www/python/static
    <Directory /var/www/python/static>
        Require all granted
    </Directory>

    ErrorLog /var/log/httpd/python_error.log
    CustomLog /var/log/httpd/python_access.log combined
    LogLevel warn
</VirtualHost>
```

 - Final Steps and Testing
```bash
# Test Apache configuration
sudo apachectl configtest

# If using SELinux (RHEL/CentOS/Fedora)
sudo setsebool -P httpd_execmem 1
sudo chcon -R -t httpd_sys_content_t /var/www/python

# Restart Apache
sudo systemctl restart httpd

# Check status
sudo systemctl status httpd
```

Test the application: `http://127.0.0.1/` or `http://localhost/`

<img width="803" height="601" alt="Screenshot 2025-11-07 at 9 48 03 AM" src="https://github.com/user-attachments/assets/2bd4f8f4-1e42-41d8-b9da-a5bf8e0b04cb" />


---


**8. Hosting a Secure Site (HTTPS/SSL with Apache)**

**A. Install SSL Packages**
```bash
# Check existing packages
rpm -q httpd mod_ssl openssl

# Install if missing
sudo dnf install mod_ssl openssl -y
```

**B. Firewall configuration**
```bash
# Enable HTTPS in firewall
sudo firewall-cmd --permanent --add-service=https
sudo firewall-cmd --reload
sudo firewall-cmd --list-all
```

**C. Generate Self-Signed Certificate**
```bash
# Create certificate directory
sudo mkdir -p /etc/pki/tls/private
sudo mkdir -p /etc/pki/tls/certs

# Generate self-signed certificate
sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
    -keyout /etc/pki/tls/private/localhost.key \
    -out /etc/pki/tls/certs/localhost.crt \
    -subj "/C=US/ST=State/L=City/O=Organization/CN=localhost"
```

**D. SSL Virtual Host Configuration**
 - SSL configuration `sudo vim /etc/httpd/conf.d/ssl.conf`
```
SSLCertificateFile /etc/pki/tls/certs/localhost.crt
SSLCertificateKeyFile /etc/pki/tsl/private/localhost.key
```
<img width="652" height="176" alt="Screenshot 2025-11-07 at 10 57 12 AM" src="https://github.com/user-attachments/assets/269bbbd9-b7b0-4233-be1f-1fc995e87400" />

 - Virtual host configuration
```bash
sudo vim /etc/httpd/conf.d/ssl-website.conf
```
```apache
<VirtualHost *:443>
    ServerName www.devopsclass.com
    DocumentRoot /var/www/devopsclass
    
    # SSL Configuration
    SSLEngine on
    SSLCertificateFile /etc/pki/tls/certs/localhost.crt
    SSLCertificateKeyFile /etc/pki/tls/private/localhost.key
    
    # Security headers
    Header always set Strict-Transport-Security "max-age=63072000; includeSubDomains; preload"
    Header always set X-Content-Type-Options nosniff
    Header always set X-Frame-Options DENY
    
    <Directory "/var/www/devopsclass">
        Options -Indexes +FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>
    
    ErrorLog /var/log/httpd/ssl_error.log
    CustomLog /var/log/httpd/ssl_access.log combined
</VirtualHost>

# Redirect HTTP to HTTPS
<VirtualHost *:80>
    ServerName www.devopsclass.com
    Redirect permanent / https://www.devopsclass.com/
</VirtualHost>
```

**E. Directory & Permissions**
```bash
# Create website directory
sudo mkdir -p /var/www/devopsclass
```

 `sudo vim /var/www/devopsclass/index.html`
```html
<!doctype html>
<meta charset="utf-8">
<title>HTTPS Test</title>
<pre id="out"></pre>
<script>
  const secure = location.protocol === 'https:' && window.isSecureContext;
  document.getElementById('out').textContent =
    `${secure ? 'Secure (HTTPS)' : 'Not secure'}\nProtocol: ${location.protocol}\nHost: ${location.host}`;
</script>
```
  
```bash
# Set permissions
sudo chown -R apache:apache /var/www/devopsclass
sudo chmod -R 755 /var/www/devopsclass

# Test and restart
sudo httpd -t
sudo systemctl restart httpd
```

**G. Restart & Test**
```bash
httpd -t
systemctl restart httpd
```

Test: `https://127.0.0.1/`  
(Proceed past the browser warning for self-signed certificate)

<img width="1014" height="743" alt="Screenshot 2025-11-07 at 11 02 44 AM" src="https://github.com/user-attachments/assets/2b384eff-8cf3-479d-bc52-16c9498f625b" />

<img width="800" height="244" alt="Screenshot 2025-11-07 at 11 03 16 AM" src="https://github.com/user-attachments/assets/ee0f680d-85ef-4040-99a3-3689146186ce" />


---

**A. Remove/Stop Apache (if needed)**
 - If multiple services use the same port number on the same server, issues will occur. There are several ways to manage this, but for now, let’s simply disable, stop, or uninstall Apache.
 
```bash
systemctl disable httpd
systemctl stop httpd
dnf -y remove httpd
```

---


## 9. Nginx Web Server

 - NGINX provides a high-performance, event-driven architecture with the ability to handle extreme concurrent loads efficiently. Unlike traditional servers (like older Apache), which spawn a new process or thread for every connection, thereby consuming resources, NGINX uses a streamlined process model.
 
 - It also functions as a reverse proxy, load balancer, mail proxy, HTTP cache, and API Gateway.
 
 - NGINX's performance edge comes from its unique architecture, which differs from traditional servers that use a new process or thread for each connection (e.g., older Apache configurations).
 
 - Master and Worker Processes
   - NGINX runs one master process that undertakes privileged tasks, like reading configuration and binding ports, and several single-threaded worker processes responsible for request handling.
 - Event-Driven Model:
   - Each worker process responds in an extremely effective event-driven and non-blocking way to handle thousands of concurrent connections within a single thread. The worker will register event handlers for various connection states, continuing its processing with the rest of the events without waiting for I/O to complete; therefore, minimal use of resources.


**Installation and Setup**
```bash
# Install Nginx
sudo dnf install nginx -y

# Start and enable
sudo systemctl start nginx
sudo systemctl enable nginx
sudo systemctl status nginx

# Firewall configuration
sudo firewall-cmd --permanent --add-service=http
sudo firewall-cmd --permanent --add-service=https
sudo firewall-cmd --reload
```

**Configuration Structure**
```bash
ls /etc/nginx
```
```text
/etc/nginx/                                         # Main NGINX configuration directory
├── conf.d/                                         # Extra configuration files loaded automatically
├── default.d/                                      # Default server config snippets included by nginx.conf
├── fastcgi.conf                                    # FastCGI parameters for PHP or other backends
├── fastcgi_params                                  # Legacy FastCGI parameter definitions
├── mime.types                                      # Maps file extensions to MIME types
├── nginx.conf                                      # Primary NGINX configuration file
└── (plus various *.default and encoding files)     # Backup and charset mapping files
```


**Key Configuration File**
 - It defines global NGINX behavior and tells NGINX where to find additional configuration files.
 
`sudo vim /etc/nginx/nginx.conf`
```nginx
# nginx.conf core structure
events {                                         # Controls general connection handling
    worker_connections 1024;                     # Maximum simultaneous connections per worker
}

http {                                           # Main HTTP configuration block
    include /etc/nginx/mime.types;               # Loads file type mappings (MIME types)
    include /etc/nginx/conf.d/*.conf;            # Includes all site/server configs from conf.d/
    include /etc/nginx/sites-enabled/*;          # Includes enabled virtual host files (if used)
}
```


**Basic Configuration (Nginx Server Block)**

 - This is a server block (sometimes called a virtual host). It defines how NGINX should respond to requests for a specific domain or IP.
 - Syntax:

```nginx
server {                                      # Defines a virtual host or website block
    listen <port>;                            # Port number to listen on (e.g., 80 or 443)
    server_name <domain_or_IP>;               # Domain name or IP address to respond to
    root <document_root_path>;                # Directory containing website files
    index <index_file>;                       # Default file served when accessing the site

    location <path> {                         # Defines how to handle specific request paths
        <directive> <value>;                  # Configuration directive(s) for this path
        ...                                   # Additional directives if needed
    }
}
```

**Example 1: Static File Server**
```bash
# Create site directory
sudo mkdir -p /usr/share/nginx/devops
```

`sudo vim /usr/share/nginx/devops/index.html`

```bash
<!DOCTYPE html>
<html>
<head>
    <title>Nginx Test</title>
</head>
<body>
    <h1>Testing Nginx Web Server</h1>
    <p>Nginx is running successfully!</p>
</body>
</html>
```

 - Nginx Server Block:`sudo vim /etc/nginx/conf.d/devops.conf`
 
```nginx
server {                                                 # Defines a virtual host (website) configuration
    listen 80;                                            # Listens on port 80 for HTTP requests
    listen [::]:80;
    server_name 192.168.64.4 www.devops.com 127.0.0.1 localhost;             # Responds to these domain names or IPs
    root /usr/share/nginx/devops;                                            # Root directory for website files
    index index.html index.htm;                                              # Default index files to serve

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;                  # Prevents clickjacking (same origin only)
    add_header X-XSS-Protection "1; mode=block" always;              # Enables XSS filtering in browsers
    add_header X-Content-Type-Options "nosniff" always;              # Blocks MIME type sniffing

    # Logging
    access_log /var/log/nginx/devops_access.log;                     # Log file for successful requests
    error_log /var/log/nginx/devops_error.log;                       # Log file for errors

    location / {                                                     # Defines behavior for requests to the site root
        try_files $uri $uri/ =404;                                   # Serve file if exists, else return 404
    }

    # Deny access to hidden files
    location ~ /\. {                                     # Matches hidden files (starting with .)
        deny all;                                        # Denies access to such files
        access_log off;                                  # Disables access logging for them
        log_not_found off;                               # Prevents logging missing hidden files
    }
}

```

```bash
# Test configuration
sudo nginx -t

# Restart Nginx
sudo systemctl restart nginx
```

Test: `http://127.0.0.1/`
<img width="836" height="287" alt="Screenshot 2025-11-09 at 7 25 10 AM" src="https://github.com/user-attachments/assets/bbeabf3b-7d6a-4d6d-bf5d-95e3601a4205" />


---
**10 SSL/TLS Configuration**

```nginx
server {
    listen 443 ssl http2;
    server_name example.com;
    
    ssl_certificate /etc/ssl/certs/example.com.crt;
    ssl_certificate_key /etc/ssl/private/example.com.key;
    
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    
    # HSTS
    add_header Strict-Transport-Security "max-age=63072000" always;
}
```

**Security Headers**
```nginx
server {
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downtrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
}
```


---

**Performance Tuning**

 - Worker Configuration
```nginx
# nginx.conf
worker_processes auto;        # Match CPU cores
worker_rlimit_nofile 65536;   # File descriptors

events {
    worker_connections 8192;  # Connections per worker
    use epoll;                # Linux event mechanism
    multi_accept on;
}
```

 - Buffer & Timeout Optimization
```nginx
http {
    client_body_buffer_size 128k;
    client_max_body_size 20m;
    client_header_buffer_size 1k;
    
    keepalive_timeout 65;
    keepalive_requests 1000;
    
    # Gzip compression
    gzip on;
    gzip_types text/plain text/css application/json application/javascript;
}
```

---


**12. Enterprise Enhancements**

**A. Advanced Application-Level Monitoring (APM)**
- Integrate tools like New Relic, Datadog APM, and Elastic APM for real-time web transaction tracing, error detection, and performance analytics.
- Instrument web apps for latency, throughput, slow queries, distributed tracing, and user experience.


**B. Automated Certificate Management (Let's Encrypt, Certbot)**
- Use Certbot for free SSL/TLS certificates and auto-renewal:
  ```bash
  sudo dnf install certbot python3-certbot-apache
  sudo certbot --apache
  
  # For Nginx:
  sudo dnf install certbot python3-certbot-nginx
  sudo certbot --nginx
  
  # Schedule renewal:
  echo "0 0 * * * certbot renew --quiet" | sudo tee /etc/cron.d/certbot-renew
  ```
- Integrate certificate lifecycle management with monitoring and alerting.


**C. Infrastructure as Code (IaC)**
- Use Terraform and Ansible for automated, repeatable deployments of web servers, load balancers, firewalls, certificates, and DNS.
- Example: Terraform for AWS EC2 + Ansible for Apache setup.
- Store configurations in version control and integrate with CI/CD for automated provisioning and rollback.


**D. Containerized Web Servers (Docker, Kubernetes Ingress)**
- Deploy web servers as Docker containers for portability and scalability:
  - Example:  
    ```bash
    docker run -d -p 80:80 --name webserver -v /site:/usr/share/nginx/html nginx
    ```
    
- Use Kubernetes with Ingress controllers for scalable, self-healing deployments, SSL termination, and advanced routing.
- Define web apps and load balancers in YAML manifests and manage with `kubectl`.


**E. CI/CD Integration for Automated Updates**
- Connect GitHub/GitLab CI/CD pipelines to build, test, and deploy web server updates automatically.
- Example:  
  - Push to the main branch triggers the Ansible playbook or Docker build/deploy.
  - Use pipeline stages for syntax check (`nginx -t`, `httpd -t`), unit/integration tests, and production rollout.


**F. Web Application Firewall (WAF) Configuration**
- Deploy WAFs (e.g., ModSecurity for Apache/Nginx, AWS WAF, Cloudflare WAF) to block attacks (SQL injection, XSS, etc).
- Configure security rules, monitor logs, and integrate with SIEM for threat detection.
- Example for ModSecurity with Apache:
  ```bash
  sudo dnf install mod_security
  sudo systemctl restart httpd
  ```
- For Nginx: Use open source WAF modules or integrate with cloud WAF services.


---

**References**

- `man httpd`, `man nginx`, `man firewall-cmd`, `man openssl`, `man docker`, `man kubectl`
- [Apache HTTP Server Docs](https://httpd.apache.org/docs/)
- [Nginx Docs](https://nginx.org/en/docs/)
- [Let’s Encrypt Certbot](https://certbot.eff.org/)
- [Terraform](https://www.terraform.io/docs/)
- [Ansible](https://docs.ansible.com/)
- [New Relic APM](https://docs.newrelic.com/docs/apm/)
- [Datadog APM](https://docs.datadoghq.com/apm/)
- [Elastic APM](https://www.elastic.co/guide/en/apm/get-started/current/overview.html)
- [Docker Docs](https://docs.docker.com/)
- [Kubernetes Ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/)
- [GitHub Actions](https://docs.github.com/en/actions)
- [GitLab CI/CD](https://docs.gitlab.com/ee/ci/)
- [ModSecurity](https://modsecurity.org/)
- [AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/)
- [Cloudflare WAF](https://developers.cloudflare.com/waf/)

---
